// mobile-app/app/_layout.tsx

import React, { useEffect, useRef } from 'react';

import { Stack, router } from 'expo-router'; // Importa 'router' de expo-router

import { StatusBar } from 'expo-status-bar';



// Importa tus funciones de utilidad para notificaciones

import { registerForPushNotificationsAsync, setupNotificationListeners } from '../src/utils/notifications'; // Ajusta la ruta si es necesario



export default function RootLayout() {

  useEffect(() => {

    let cleanupListeners: (() => void) | undefined;



    const setupNotifications = async () => {

      // 1. Obtener el token y enviarlo a tu backend

      const token = await registerForPushNotificationsAsync();

      if (token) {

        console.log("Expo Push Token:", token);

        // IMPORTANTE: NO ENVÍES EL TOKEN AL BACKEND AQUÍ.

        // Esto se hace en tu pantalla de LOGIN (app/(tabs)/index.tsx)

        // una vez que el usuario esté autenticado y sepas su userId y userType.

      }



      // 2. Configurar listeners para notificaciones

      // Pasamos el objeto 'router' para que la utilidad pueda navegar

      cleanupListeners = setupNotificationListeners(router);

    };



    setupNotifications();



    // Limpia los listeners cuando el componente se desmonte

    return () => {

      if (cleanupListeners) {

        cleanupListeners();

      }

    };

  }, []); // El array vacío asegura que esto se ejecute solo una vez al montar



  return (

    <>

      <StatusBar style="light" /> {/* Puedes ajustar el estilo de la barra de estado */}

      <Stack>

        {/* Aquí defines tu estructura de navegación principal con Expo Router */}



        {/* LoginScreen */}

        <Stack.Screen name="index" options={{ headerShown: false }} />

        {/* Pantalla de Registro */}

        <Stack.Screen name="signup" options={{ headerShown: false }} />



        {/* Rutas para Postulante */}

        <Stack.Screen name="postulante/dashboard" options={{ headerShown: false }} />

        <Stack.Screen name="postulante/notificaciones" options={{ title: 'Mis Notificaciones' }} />

        {/* Si Postulante tiene su propio _layout.tsx para sub-rutas, puedes usar: */}

        {/* <Stack.Screen name="postulante" options={{ headerShown: false }} /> */}



        {/* Rutas para Empresa */}

        <Stack.Screen name="empresa/dashboard" options={{ headerShown: false }} />

        <Stack.Screen name="empresa/notificaciones" options={{ title: 'Mis Notificaciones' }} />

        {/* Si Empresa tiene su propio _layout.tsx, puedes usar: */}

        {/* <Stack.Screen name="empresa" options={{ headerShown: false }} /> */}

       

        {/* Ruta para el manejo de "no encontrado" */}

        <Stack.Screen name="+not-found" />

      </Stack>

    </>

  );

} //mobile-app/app/index.tsx: 
import React, { useState, useEffect } from 'react';

import {

  View,

  Text,

  TextInput,

  TouchableOpacity,

  StyleSheet,

  Image,

  Dimensions,

  Platform,

  Alert,

  ActivityIndicator

} from 'react-native';

import { useFonts } from 'expo-font';

import { router } from 'expo-router';

import * as Device from 'expo-device';



// Importa tus funciones API y de notificaciones

import { loginUser, registerPushTokenOnBackend } from '../src/services/api';

import { registerForPushNotificationsAsync } from '../src/utils/notifications';



// Obtener el ancho de la pantalla para estilos responsivos si es necesario

const { width } = Dimensions.get('window');



// Estilos de color y fuente (adaptados de tu styleguide.css)

// Puedes crear un archivo separado para esto, ej: src/constants/colors.ts, src/constants/fonts.ts

const Colors = {

  neutrals100: '#25324B',

  neutrals40: '#A8ADBB',

  neutrals80: '#515B6F',

  neutrals0: '#FFFFFF',

  black: '#202430',

  brandsSecondary: '#CCCCF5',

  neutrals20: '#D6DDEB',

  techBridgeBlue: '#0A5CB8', // De tu css para el color del botón y links

  techBridgeLightBlue: '#C2DFFF', // Color de fondo del tab "Postulante"

};



// Se necesitan las fuentes en el proyecto

// Asegúrate de tener los archivos .ttf de estas fuentes en tu carpeta assets/fonts/

// o similar, y cárgalas correctamente.

// Aquí solo simulamos que ya están cargadas.

const FontFamilies = {

  epilogueSemiBold: 'Epilogue-SemiBold', // Mapping for font loading

  epilogueRegular: 'Epilogue-Regular',

  epilogueBold: 'Epilogue-Bold', // For button-normal-font-weight: 700

  leagueSpartanSemiBold: 'LeagueSpartan-SemiBold', // For 32px title

  interSemiBold: 'Inter-SemiBold', // For "Crea una cuenta"

};



export default function LoginScreen() {

  const [email, setEmail] = useState('');

  const [password, setPassword] = useState('');

  const [isLoading, setIsLoading] = useState(false);

  const [activeTab, setActiveTab] = useState<'estudiante' | 'empresa'>('estudiante');

  const [rememberMe, setRememberMe] = useState(false); // Para el checkbox



  // Carga de fuentes (asegúrate de que los archivos estén en assets/fonts)

  const [fontsLoaded] = useFonts({

    'Epilogue-SemiBold': require('../assets/fonts/Epilogue-SemiBold.ttf'), // Ajusta la ruta

    'Epilogue-Regular': require('../assets/fonts/Epilogue-Regular.ttf'),   // Ajusta la ruta

    'Epilogue-Bold': require('../assets/fonts/Epilogue-Bold.ttf'),         // Ajusta la ruta

    'LeagueSpartan-SemiBold': require('../assets/fonts/LeagueSpartan-SemiBold.ttf'), // Ajusta la ruta

    'Inter-SemiBold': require('../assets/fonts/Inter_28pt-SemiBold.ttf'),       // Ajusta la ruta

  });



  const handleLogin = async () => {

    setIsLoading(true); // Mostrar indicador de carga

    try {

      // 1. Intentar iniciar sesión con el backend

      // Se pasa un objeto con 'correo' y 'contrasena' (nombres de campos que espera tu backend)

      // Se pasa 'activeTab' para que loginUser sepa qué endpoint usar

      const loginResponse = await loginUser({ correo: email, contrasena: password }, activeTab);

      // loginResponse debería ser un objeto como: { userId: 1, userType: 'postulante', token: 'tu_jwt_aqui' }



      console.log('LoginScreen: loginResponse después de llamar a loginUser:', loginResponse); // <-- Añade esto

      // 2. Si el login es exitoso, obtener el token de notificación del dispositivo

      if (loginResponse && loginResponse.userId && loginResponse.userType && loginResponse.token) {

        // 3. Obtener el token de notificación del dispositivo

        const expoPushToken = await registerForPushNotificationsAsync();

        console.log('🎉 Expo Push Token OBTENIDO DESDE LA APP:', expoPushToken); // ¡IMPORTANTE!



        // Añade una alerta para que el token se muestre en la pantalla del dispositivo/emulador

        if (expoPushToken) {

            Alert.alert(

                'Token Obtenido',

                `Tu Expo Push Token es:\n\n${expoPushToken}\n\nCópialo para Postman.`,

                [{ text: 'OK' }]

            );

        } else {

            Alert.alert('Error', 'No se pudo obtener el Expo Push Token.');

        }

        // 4. Enviar el token de notificación y los datos del usuario al backend

        if (expoPushToken) {

          await registerPushTokenOnBackend(

            loginResponse.userId,

            loginResponse.userType, // Usa el userType que viene del backend

            expoPushToken,

            loginResponse.token // Pasa el token de sesión (JWT) para autenticar la petición

          );

          console.log('Token de notificación registrado con éxito en el backend.');

        } else {

          console.warn('No se pudo obtener el token de Expo Push para registrar.');

        }



        // 5. Navegar a la pantalla principal después de un login exitoso y registro de token

        if (loginResponse.userType === 'estudiante') {

          router.replace('/postulante/dashboard'); // Redirigir al dashboard del postulante

        } else if (loginResponse.userType === 'empresa') {

          router.replace('/empresa/dashboard'); // Redirigir al dashboard de la empresa

        } else {

          // En caso de que el userType devuelto por el backend no sea ni 'postulante' ni 'empresa'

          Alert.alert('Error de inicio de sesión', 'Tipo de usuario no reconocido. Por favor, contacta a soporte.');

        }



      } else {

        // En caso de una respuesta exitosa pero con datos incompletos (raro si el backend está bien)

        console.log('LoginScreen: loginResponse es incompleto o falsy:', loginResponse); // <-- Añade esto

        Alert.alert('Error de inicio de sesión', loginResponse?.mensaje || 'Credenciales inválidas o datos de usuario incompletos recibidos.');

      }



    } catch (error: any) {

      // Manejo de errores de la API (ej. 401 Credenciales inválidas, Network request failed)

      console.error('Error durante el inicio de sesión o registro de token:', error);

      Alert.alert('Error', error.message || 'Ocurrió un error inesperado al iniciar sesión.');

    } finally {

      setIsLoading(false); // Ocultar indicador de carga

    }

  };



  if (!fontsLoaded) {

    return <ActivityIndicator size="large" color={Colors.techBridgeBlue} style={{ flex: 1, justifyContent: 'center' }} />;

  }



  return (

    <View style={styles.loginPostulante}>

      <View style={styles.topNav}>

        <Image

          style={styles.logo}

          source={{ uri: 'https://c.animaapp.com/mOfRBxl8/img/logo-3.png' }}

        />

      </View>

      <View style={styles.landingPageLogin}>

        <View style={styles.frame}>

          <View style={styles.signUpOptions}>

            <TouchableOpacity

              style={[styles.tabBase, activeTab === 'estudiante' ? styles.activeTab : styles.inactiveTab]} // Modificado

              onPress={() => setActiveTab('estudiante')}

            >

              <Text style={[styles.caption, activeTab === 'estudiante' && styles.activeCaption]}>Postulante</Text>

            </TouchableOpacity>

            <TouchableOpacity

              style={[styles.tabBase, activeTab === 'empresa' ? styles.activeTab : styles.inactiveTab]} // Modificado

              onPress={() => setActiveTab('empresa')}

            >

              <Text style={[styles.caption, activeTab === 'empresa' && styles.activeCaption]}>Empresa</Text>

            </TouchableOpacity>

          </View>

          {activeTab === 'estudiante' && (

            <Text style={styles.welcomeBackDude}>Obten más oportunidades</Text>

          )}

          {activeTab === 'empresa' && (

            <Text style={styles.welcomeBackDude}>Impulsa tu empresa</Text>

          )}

        </View>



        <View style={styles.forms}>

          <View style={styles.textfield}>

            <Text style={styles.label}>Correo</Text>

            <View style={styles.input}>

              <TextInput

                style={styles.textInputStyle}

                placeholder="Ingresa tu correo"

                placeholderTextColor={Colors.neutrals40}

                value={email}

                onChangeText={setEmail}

                keyboardType="email-address"

                autoCapitalize="none"

              />

            </View>

          </View>

          <View style={styles.textfield}>

            <Text style={styles.label}>Contraseña</Text>

            <View style={styles.input}>

              <TextInput

                style={styles.textInputStyle}

                placeholder="Ingresa tu contraseña"

                placeholderTextColor={Colors.neutrals40}

                value={password}

                onChangeText={setPassword}

                secureTextEntry

              />

            </View>

          </View>

         

          <TouchableOpacity style={styles.rememberMe} onPress={() => setRememberMe(!rememberMe)}>

            <View style={styles.checkbox}>

              <Image

                style={styles.checkboxChecked}

                source={{

                  uri: rememberMe

                    ? 'https://c.animaapp.com/mOfRBxl8/img/checkbox-checked3.svg'

                    : 'https://c.animaapp.com/mOfRBxl8/img/checkbox-unchecked.svg', // Asegúrate de tener esta imagen

                }}

              />

              <Text style={styles.div}>Recordarme en este dispositivo</Text>

            </View>

          </TouchableOpacity>



          <TouchableOpacity

            style={styles.divWrapper}

            onPress={handleLogin}

            disabled={isLoading}

          >

            {isLoading ? (

              <ActivityIndicator color={Colors.neutrals0} />

            ) : (

              <Text style={styles.caption2}>Iniciar Sesión</Text>

            )}

          </TouchableOpacity>

        </View>



        <View style={styles.alreadyHaveAn}>

          <Text style={styles.dontHaveAn}>¿No tienes una cuenta?</Text>

          <TouchableOpacity onPress={() => router.push('/signup')}> {/* Asume una ruta de registro */}

            <Text style={styles.signUp}>Crea una cuenta</Text>

          </TouchableOpacity>

        </View>

      </View>

    </View>

  );

}



// --- StyleSheet para React Native ---

const styles = StyleSheet.create({

  loginPostulante: {

    flex: 1,

    backgroundColor: Colors.neutrals0,

    justifyContent: 'center', // ¡NUEVO! Centra los hijos verticalmente

    alignItems: 'center',     // ¡NUEVO! Centra los hijos horizontalmente (si es necesario para todo el contenedor)

    paddingTop: 50,

    paddingVertical: 20, // Opcional: añadir un poco de padding vertical si todo se pega a los bordes

  },

  topNav: {

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'space-around',

    paddingTop: 37,

    paddingHorizontal: 16,

    paddingBottom: 0,

    width: '100%',

    backgroundColor: Colors.neutrals0,

  },

  logo: {

    width: 240,

    height: 80,

    resizeMode: 'contain',

    marginTop: -1,

  },

  landingPageLogin: {

    flex: 1,

    flexDirection: 'column',

    width: '100%',

    maxWidth: 383,

    alignSelf: 'center',

    alignItems: 'flex-start',

    gap: 24,

    paddingHorizontal: 16,

    paddingVertical: 40,

    backgroundColor: Colors.neutrals0,

  },

  frame: {

    flexDirection: 'column',

    alignItems: 'center',

    gap: 24,

    width: '100%',

  },

  signUpOptions: {

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'center',

  },

  tabMenu: {

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'center',

    paddingVertical: 7,

    paddingHorizontal: 12,

    backgroundColor: Colors.techBridgeLightBlue,

  },

  caption: {

    fontFamily: FontFamilies.epilogueSemiBold,

    fontSize: 16,

    letterSpacing: 0,

    lineHeight: 16 * 1.6,

    color: Colors.neutrals100,

    marginTop: -1,

  },

  activeTab: {

    backgroundColor: Colors.techBridgeLightBlue,

  },

  inactiveTab: {

    backgroundColor: Colors.neutrals0, // El color de fondo cuando NO está activo

    // Aquí puedes añadir un borde si quieres diferenciarlos más cuando están inactivos

    // borderWidth: 1,

    // borderColor: Colors.neutrals20,

  },

  activeCaption: {

    color: Colors.techBridgeBlue,

  },

  tabBase: {

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'center',

    paddingVertical: 7,

    paddingHorizontal: 12,

    // NO pongas backgroundColor aquí si quieres que el 'inactiveTab' lo defina

    // o si el fondo global del contenedor de pestañas ya es neutro.

    // Podrías poner un borderRadius o un borde aquí si es común para ambos.

  },

  captionWrapper: {

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'center',

    paddingVertical: 7,

    paddingHorizontal: 12,

    backgroundColor: Colors.neutrals0,

  },

  welcomeBackDude: {

    width: '100%',

    fontFamily: FontFamilies.leagueSpartanSemiBold,

    fontSize: 32,

    lineHeight: 38.4,

    textAlign: 'center',

    color: Colors.neutrals100,

  },

  orSignUpWith: {

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'center',

    gap: 8,

    width: '100%',

  },

  line: {

    flex: 1,

    height: 1,

    backgroundColor: Colors.neutrals20,

  },

  orLoginWithEmail: {

    fontFamily: FontFamilies.epilogueRegular,

    fontSize: 16,

    letterSpacing: 0,

    lineHeight: 16 * 1.6,

    color: Colors.neutrals40,

    textAlign: 'center',

    marginTop: -1,

  },

  forms: {

    flexDirection: 'column',

    alignItems: 'flex-start',

    gap: 22,

    width: '100%',

  },

  textfield: {

    flexDirection: 'column',

    alignItems: 'flex-start',

    gap: 4,

    width: '100%',

  },

  label: {

    fontFamily: FontFamilies.epilogueSemiBold,

    fontSize: 16,

    letterSpacing: 0,

    lineHeight: 16 * 1.6,

    color: Colors.neutrals80,

    marginTop: -1,

  },

  input: {

    flexDirection: 'row',

    alignItems: 'center',

    paddingVertical: 12,

    paddingHorizontal: 16,

    width: '100%',

    backgroundColor: Colors.neutrals0,

    borderWidth: 1,

    borderColor: Colors.neutrals20,

  },

  textInputStyle: {

    flex: 1,

    fontFamily: FontFamilies.epilogueRegular,

    fontSize: 16,

    color: Colors.neutrals100,

  },

  rememberMe: {

    width: '100%',

    height: 26,

    justifyContent: 'center',

  },

  checkbox: {

    flexDirection: 'row',

    alignItems: 'center',

    gap: 16,

  },

  checkboxChecked: {

    width: 24,

    height: 24,

    resizeMode: 'contain',

  },

  div: {

    fontFamily: FontFamilies.epilogueRegular,

    fontSize: 16,

    letterSpacing: 0,

    lineHeight: 16 * 1.6,

    color: Colors.neutrals80,

    marginTop: -1,

  },

  divWrapper: {

    paddingVertical: 12,

    paddingHorizontal: 24,

    backgroundColor: Colors.techBridgeBlue,

    flexDirection: 'row',

    alignItems: 'center',

    justifyContent: 'center',

    gap: 10,

    width: '100%',

  },

  caption2: {

    fontFamily: FontFamilies.epilogueBold,

    fontSize: 16,

    letterSpacing: 0,

    lineHeight: 16 * 1.6,

    color: Colors.neutrals0,

    textAlign: 'center',

    marginTop: -1,

  },

  alreadyHaveAn: {

    flexDirection: 'row',

    alignItems: 'flex-start',

    gap: 8,

    marginBottom: -14,

  },

  dontHaveAn: {

    fontFamily: FontFamilies.epilogueRegular,

    fontSize: 16,

    letterSpacing: 0,

    lineHeight: 16 * 1.6,

    color: Colors.black,

    marginTop: -1,

    opacity: 0.7,

  },

  signUp: {

    fontFamily: FontFamilies.interSemiBold,

    fontSize: 16,

    lineHeight: 24,

    color: Colors.techBridgeBlue,

    textAlign: 'center',

    marginTop: -1,

  },

}); // mobile-app/src/services/api.ts



// Asegúrate de que esta URL base esté bien configurada para tu IP/Emulador

// Si tu IP es 192.168.0.9 y tu backend corre en el puerto 3000

// mobile-app/src/config/api.ts DEBE tener: export const API_BASE_URL = 'http://192.168.0.9:3000';

import { API_BASE_URL } from '../config/api'; // Importa la URL base sin el '/api' final



// Interfaz para la respuesta de registro de token push

interface RegisterPushTokenResponse {

  message: string;

}



// Interfaz para la respuesta de login que el frontend ESPERA y NECESITA

interface FrontendLoginResponse {

  userId: number;

  userType: 'estudiante' | 'empresa'; // 'estudiante' es lo que tu backend devuelve para postulantes

  token: string; // ¡Esto es crucial y tu backend NO lo está devolviendo aún!

  mensaje?: string;

  estado: number;

}



// Función para enviar el token de Expo Push al backend

export const registerPushTokenOnBackend = async (

  userId: number,

  userType: 'estudiante' | 'empresa', // Asegúrate de que esto coincida con lo que tu backend espera ('estudiante' o 'empresa')

  expoPushToken: string,

  authToken?: string // Opcional: si tu ruta de registro de token en el backend requiere autenticación

): Promise<RegisterPushTokenResponse> => {

  try {

    const headers: HeadersInit = {

      'Content-Type': 'application/json',

    };

    // Si tu backend protege la ruta /registerPushToken, añade el token de autenticación aquí

    if (authToken) {

      headers['Authorization'] = `Bearer ${authToken}`;

    }



    // La ruta completa para el registro de token

    const response = await fetch(`${API_BASE_URL}/api/usuariosMobile/registerPushToken`, {

      method: 'POST',

      headers: headers,

      body: JSON.stringify({

        userId: userId,

        userType: userType,

        expoPushToken: expoPushToken,

      }),

    });



    if (!response.ok) {

      const errorData = await response.json();

      throw new Error(errorData.message || `Error ${response.status}: Failed to register push token.`);

    }



    return response.json(); // Devuelve la respuesta del backend

  } catch (error: any) {

    console.error('Error sending push token to backend:', error.message);

    throw error; // Propaga el error para que pueda ser manejado en el componente de login

  }

};



// Función para el login, ahora recibe el tipo de usuario

export const loginUser = async (

  credentials: { correo: string; contrasena: string }, // Cambiado a 'correo' y 'contrasena' para coincidir con tu backend

  userType: 'estudiante' | 'empresa' // Recibe el tipo de usuario para seleccionar el endpoint

): Promise<FrontendLoginResponse> => { // Ahora retorna la interfaz que el frontend necesita

  try {

    let loginEndpoint = '';

    if (userType === 'estudiante') {

      loginEndpoint = '/api/usuariosMobile/estudianteLogin'; // Ruta correcta para postulantes

    } else if (userType === 'empresa') {

      loginEndpoint = '/api/usuariosMobile/empresaLogin'; // Ruta correcta para empresas

    } else {

      throw new Error('Tipo de usuario no válido para el login.');

    }



    const response = await fetch(`${API_BASE_URL}${loginEndpoint}`, {

      method: 'POST',

      headers: {

        'Content-Type': 'application/json',

      },

      body: JSON.stringify(credentials),

    });

    // Si la respuesta no es OK (ej. 401 Unauthorized, 500 Internal Server Error)

    if (!response.ok) {

      const errorData = await response.json();

      throw new Error(errorData.mensaje || 'Login failed'); // Usa errorData.mensaje

    }



    // ***********************************************************************************

    // *** ¡ATENCIÓN CRÍTICA AQUÍ! ***

    // Tu backend actualmente devuelve { estado, mensaje, id }.

    // Para que el frontend funcione correctamente (especialmente con el registro de push token

    // y la navegación), NECESITA que el backend devuelva:

    // { userId: number, userType: 'estudiante' | 'empresa', token: string }

    //

    // Por ahora, estoy simulando la respuesta esperada para que el frontend no falle,

    // pero DEBES MODIFICAR TU BACKEND para que devuelva 'userType' y un 'token' JWT.

    // ***********************************************************************************



    // Mapea la respuesta actual del backend a la estructura que el frontend espera

    // Esto es una SOLUCIÓN TEMPORAL hasta que modifiques el backend

    const data: FrontendLoginResponse = await response.json();

    console.log('API: Datos recibidos del backend:', data); // <-- Añade esto

    return data;

  } catch (error: any) {

    console.error('Error during login API call:', error.message);

    throw error; // Propaga el error para que sea manejado por el componente que llama

  }

};



// Puedes añadir aquí otras funciones para interactuar con tu API... // mobile-app/src/utils/notifications.ts

import * as Notifications from 'expo-notifications';

import * as Device from 'expo-device'; // Importa expo-device

import Constants from 'expo-constants'; // Importa expo-constants

import { Platform } from 'react-native';

import { Router } from 'expo-router'; // Importa el tipo Router para tipado correcto



// Configura cómo se deben manejar las notificaciones cuando la app está en primer plano

// Esto es importante para decidir si la notificación se muestra como un banner, si reproduce sonido, etc.

Notifications.setNotificationHandler({

  handleNotification: async () => ({

    shouldShowAlert: true,

    shouldPlaySound: false,

    shouldSetBadge: false,

    // Agrega estas dos propiedades que faltan según el error

    shouldShowBanner: true, // Esto es generalmente lo que quieres para notificaciones push

    shouldShowList: true,   // Esto es para mostrar en la lista de notificaciones del sistema

  }),

});



/**

 * Solicita permisos de notificación al usuario y obtiene el token de Expo Push para el dispositivo.

 * Este token es el que tu backend usará para enviar notificaciones push.

 * @returns {Promise<string | undefined>} El token de Expo Push o undefined si no se pudo obtener.

 */

export async function registerForPushNotificationsAsync(): Promise<string | undefined> {

  let token;



  // Asegúrate de que el código se ejecute en un dispositivo físico para las notificaciones push

  if (Device.isDevice) {

    // Comprobar el estado actual de los permisos

    const { status: existingStatus } = await Notifications.getPermissionsAsync();

    let finalStatus = existingStatus;



    // Si los permisos no han sido otorgados, solicitarlos

    if (existingStatus !== 'granted') {

      const { status } = await Notifications.requestPermissionsAsync();

      finalStatus = status;

    }



    // Si los permisos no se otorgaron, alertar al usuario

    if (finalStatus !== 'granted') {

      alert('Failed to get push token for push notification!');

      return;

    }



    // Si es Android, configura un canal de notificación (obligatorio desde Android 8.0)

    if (Platform.OS === 'android') {

      await Notifications.setNotificationChannelAsync('default', {

        name: 'default',

        importance: Notifications.AndroidImportance.MAX, // Muestra la notificación de forma destacada

        vibrationPattern: [0, 250, 250, 250], // Patrón de vibración

        lightColor: '#FF231F7C', // Color de la luz LED si el dispositivo lo soporta

      });

    }



    // Obtener el token de Expo Push

   

    token = (await Notifications.getExpoPushTokenAsync({

      projectId: Constants.expoConfig?.extra?.eas?.projectId || Constants.expoConfig?.owner  // Expo Router usa projectId de app.json/app.config.js o el owner

    })).data;



    console.log('Expo Push Token:', token);

    return token;



  } else {

    // Si no es un dispositivo físico, no se pueden obtener tokens de push

    alert('Must use physical device for Push Notifications');

  }



  return undefined;

}



/**

 * Escucha las notificaciones recibidas y las interacciones del usuario con ellas.

 * @param {Router} router - El objeto 'router' de Expo Router para la navegación.

 * @returns {() => void} Una función para limpiar los listeners al desmontar el componente.

 */

export function setupNotificationListeners(router: Router) { // Cambiado 'any' por 'Router' para mejor tipado

  // Listener para notificaciones recibidas mientras la app está en primer plano

  const notificationListener = Notifications.addNotificationReceivedListener(notification => {

    console.log("Notification received in foreground:", notification);

    // Aquí puedes hacer algo en la UI si la app está abierta, como mostrar un banner flotante

  });



  // Listener para cuando el usuario presiona o interactúa con una notificación

  const responseListener = Notifications.addNotificationResponseReceivedListener(response => {

    console.log("Notification tapped/interacted:", response);

    // Extraer datos personalizados de la notificación

    // Asumimos que `data` contiene `{ screen: 'postulanteNotificaciones', itemId: 'ID_DE_LA_OFERTA' }`

    const { screen, ...data } = response.notification.request.content.data; // Desestructuramos 'screen' y el resto de 'data'



    // Define el tipo esperado para los parámetros del router

    type RouterParams = Record<string, string | number | (string | number)[] | null | undefined>;



    if (typeof screen === 'string') { // Asegurarnos de que 'screen' sea una cadena

      console.log(`Navigating to ${screen} with data:`, data);



      // Lógica de redirección basada en la pantalla y, opcionalmente, otros datos

      switch (screen) {

        case 'postulanteDashboard':

          router.push('/postulante/dashboard');

          break;

        case 'postulanteNotificaciones':

          // Ejemplo: Si itemId es el ID de una oferta, navegar a una pantalla de detalle de oferta

          router.push({ pathname: '/postulante/notificaciones', params: data as RouterParams});

          break;

        case 'empresaDashboard':

          router.push('/empresa/dashboard');

          break;

        case 'empresaNotificaciones':

          // Ejemplo: Si itemId es el ID de un postulante, navegar a una pantalla de detalle del postulante

          router.push({ pathname: '/empresa/notificaciones', params: data as RouterParams});

          break;

        // Añade más casos si tienes otras pantallas a las que las notificaciones pueden redirigir

        default:

          // Redirección por defecto si la pantalla no es reconocida (ej. al dashboard principal)

          // Puedes usar router.replace si quieres que no se pueda volver a la notificación

          router.push('/postulante/dashboard'); // O a una ruta genérica como '/home'

          break;

      }

    } else {

      console.warn("Notification data 'screen' is missing or not a string, cannot navigate.");

    }

  });



  // Función para limpiar los listeners

  return () => {

    Notifications.removeNotificationSubscription(notificationListener);

    Notifications.removeNotificationSubscription(responseListener);

  };

}



// Función opcional para enviar una notificación de prueba localmente (solo para depuración)

export async function schedulePushNotification() {

  await Notifications.scheduleNotificationAsync({

    content: {

      title: "Título de Prueba! 📬",

      body: 'Este es el cuerpo de la notificación de prueba.',

      data: {

        screen: 'postulanteNotificaciones', // Ejemplo: redirige a la pantalla de notificaciones del postulante

        itemId: 'oferta123', // Ejemplo de un ID de item

        messageId: 'msg456'

      },

    },

    // Modifica el trigger para incluir 'type'

    trigger: {

      repeats: false, // Opcional: true si quieres que se repita

      seconds: 2,

      // La propiedad 'type' podría ser necesaria para algunas configuraciones

      // pero 'seconds' ya implica un TimeIntervalTrigger.

      // Si el error persiste, intenta con esto, aunque es menos común para 'seconds':

      // type: 'timeInterval', // Si esto da error, probemos sin él.

    } as Notifications.TimeIntervalTriggerInput,

  });

} //mobile-app/app.json: {

  "expo": {

    "name": "mobile-app",

    "slug": "mobile-app",

    "version": "1.0.5",

    "orientation": "portrait",

    "icon": "./assets/images/icon.png",

    "scheme": "mobileapp",

    "userInterfaceStyle": "automatic",

    "newArchEnabled": true,

    "ios": {

      "supportsTablet": true

    },

    "android": {

      "adaptiveIcon": {

        "foregroundImage": "./assets/images/adaptive-icon.png",

        "backgroundColor": "#ffffff"

      },

      "edgeToEdgeEnabled": true,

      "versionCode": 5,

      "package": "com.techbridge.app",

      "googleServicesFile": "./google-services.json"

    },

    "web": {

      "bundler": "metro",

      "output": "static",

      "favicon": "./assets/images/favicon.png"

    },

    "plugins": [

      "expo-router",

      [

        "expo-splash-screen",

        {

          "image": "./assets/images/splash-icon.png",

          "imageWidth": 200,

          "resizeMode": "contain",

          "backgroundColor": "#ffffff"

        }

      ]

    ],

    "experiments": {

      "typedRoutes": true

    },

    "extra": {

      "router": {},

      "eas": {

        "projectId": "316931be-2ce3-444d-b761-9166807370fc"

      }

    }

  }

}