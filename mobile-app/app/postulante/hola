// mobile-app/app/_layout.tsx

import React, { useEffect, useRef } from 'react';

import { Stack, router } from 'expo-router'; // Importa 'router' de expo-router

import { StatusBar } from 'expo-status-bar';



// Importa tus funciones de utilidad para notificaciones

import { registerForPushNotificationsAsync, setupNotificationListeners } from '../src/utils/notifications'; // Ajusta la ruta si es necesario



export default function RootLayout() {

 useEffect(() => {

  let cleanupListeners: (() => void) | undefined;



  const setupNotifications = async () => {

   // 1. Obtener el token y enviarlo a tu backend

   const token = await registerForPushNotificationsAsync();

   if (token) {

    console.log("Expo Push Token:", token);

    // IMPORTANTE: NO ENV칈ES EL TOKEN AL BACKEND AQU칈.

    // Esto se hace en tu pantalla de LOGIN (app/(tabs)/index.tsx)

    // una vez que el usuario est칠 autenticado y sepas su userId y userType.

   }



   // 2. Configurar listeners para notificaciones

   // Pasamos el objeto 'router' para que la utilidad pueda navegar

   cleanupListeners = setupNotificationListeners(router);

  };



  setupNotifications();



  // Limpia los listeners cuando el componente se desmonte

  return () => {

   if (cleanupListeners) {

    cleanupListeners();

   }

  };

 }, []); // El array vac칤o asegura que esto se ejecute solo una vez al montar



 return (

  <>

   <StatusBar style="light" /> {/* Puedes ajustar el estilo de la barra de estado */}

   <Stack>

    {/* Aqu칤 defines tu estructura de navegaci칩n principal con Expo Router */}



    {/* LoginScreen */}

    <Stack.Screen name="index" options={{ headerShown: false }} />

    {/* Pantalla de Registro */}

    <Stack.Screen name="signup" options={{ headerShown: false }} />



    {/* Rutas para Postulante */}

    <Stack.Screen name="postulante/dashboard" options={{ headerShown: false }} />

    <Stack.Screen name="postulante/notificaciones" options={{ title: 'Mis Notificaciones' }} />

    {/* Si Postulante tiene su propio _layout.tsx para sub-rutas, puedes usar: */}

    {/* <Stack.Screen name="postulante" options={{ headerShown: false }} /> */}



    {/* Rutas para Empresa */}

    <Stack.Screen name="empresa/dashboard" options={{ headerShown: false }} />

    <Stack.Screen name="empresa/notificaciones" options={{ title: 'Mis Notificaciones' }} />

    {/* Si Empresa tiene su propio _layout.tsx, puedes usar: */}

    {/* <Stack.Screen name="empresa" options={{ headerShown: false }} /> */}

   

    {/* Ruta para el manejo de "no encontrado" */}

    <Stack.Screen name="+not-found" />

   </Stack>

  </>

 );

} //mobile-app/app/index.tsx: 
import React, { useState, useEffect } from 'react';

import {

 View,

 Text,

 TextInput,

 TouchableOpacity,

 StyleSheet,

 Image,

 Dimensions,

 Platform,

 Alert,

 ActivityIndicator

} from 'react-native';

import { useFonts } from 'expo-font';

import { router } from 'expo-router';

import * as Device from 'expo-device';



// Importa tus funciones API y de notificaciones

import { loginUser, registerPushTokenOnBackend } from '../src/services/api';

import { registerForPushNotificationsAsync } from '../src/utils/notifications';



// Obtener el ancho de la pantalla para estilos responsivos si es necesario

const { width } = Dimensions.get('window');



// Estilos de color y fuente (adaptados de tu styleguide.css)

// Puedes crear un archivo separado para esto, ej: src/constants/colors.ts, src/constants/fonts.ts

const Colors = {

 neutrals100: '#25324B',

 neutrals40: '#A8ADBB',

 neutrals80: '#515B6F',

 neutrals0: '#FFFFFF',

 black: '#202430',

 brandsSecondary: '#CCCCF5',

 neutrals20: '#D6DDEB',

 techBridgeBlue: '#0A5CB8', // De tu css para el color del bot칩n y links

 techBridgeLightBlue: '#C2DFFF', // Color de fondo del tab "Postulante"

};



// Se necesitan las fuentes en el proyecto

// Aseg칰rate de tener los archivos .ttf de estas fuentes en tu carpeta assets/fonts/

// o similar, y c치rgalas correctamente.

// Aqu칤 solo simulamos que ya est치n cargadas.

const FontFamilies = {

 epilogueSemiBold: 'Epilogue-SemiBold', // Mapping for font loading

 epilogueRegular: 'Epilogue-Regular',

 epilogueBold: 'Epilogue-Bold', // For button-normal-font-weight: 700

 leagueSpartanSemiBold: 'LeagueSpartan-SemiBold', // For 32px title

 interSemiBold: 'Inter-SemiBold', // For "Crea una cuenta"

};



export default function LoginScreen() {

 const [email, setEmail] = useState('');

 const [password, setPassword] = useState('');

 const [isLoading, setIsLoading] = useState(false);

 const [activeTab, setActiveTab] = useState<'estudiante' | 'empresa'>('estudiante');

 const [rememberMe, setRememberMe] = useState(false); // Para el checkbox



 // Carga de fuentes (aseg칰rate de que los archivos est칠n en assets/fonts)

 const [fontsLoaded] = useFonts({

  'Epilogue-SemiBold': require('../assets/fonts/Epilogue-SemiBold.ttf'), // Ajusta la ruta

  'Epilogue-Regular': require('../assets/fonts/Epilogue-Regular.ttf'),  // Ajusta la ruta

  'Epilogue-Bold': require('../assets/fonts/Epilogue-Bold.ttf'),     // Ajusta la ruta

  'LeagueSpartan-SemiBold': require('../assets/fonts/LeagueSpartan-SemiBold.ttf'), // Ajusta la ruta

  'Inter-SemiBold': require('../assets/fonts/Inter_28pt-SemiBold.ttf'),    // Ajusta la ruta

 });



 const handleLogin = async () => {

  setIsLoading(true); // Mostrar indicador de carga

  try {

   // 1. Intentar iniciar sesi칩n con el backend

   // Se pasa un objeto con 'correo' y 'contrasena' (nombres de campos que espera tu backend)

   // Se pasa 'activeTab' para que loginUser sepa qu칠 endpoint usar

   const loginResponse = await loginUser({ correo: email, contrasena: password }, activeTab);

   // loginResponse deber칤a ser un objeto como: { userId: 1, userType: 'postulante', token: 'tu_jwt_aqui' }



   console.log('LoginScreen: loginResponse despu칠s de llamar a loginUser:', loginResponse); // <-- A침ade esto

   // 2. Si el login es exitoso, obtener el token de notificaci칩n del dispositivo

   if (loginResponse && loginResponse.userId && loginResponse.userType && loginResponse.token) {

    // 3. Obtener el token de notificaci칩n del dispositivo

    const expoPushToken = await registerForPushNotificationsAsync();

    console.log('游꿀 Expo Push Token OBTENIDO DESDE LA APP:', expoPushToken); // 춰IMPORTANTE!



    // A침ade una alerta para que el token se muestre en la pantalla del dispositivo/emulador

    if (expoPushToken) {

      Alert.alert(

        'Token Obtenido',

        `Tu Expo Push Token es:\n\n${expoPushToken}\n\nC칩pialo para Postman.`,

        [{ text: 'OK' }]

      );

    } else {

      Alert.alert('Error', 'No se pudo obtener el Expo Push Token.');

    }

    // 4. Enviar el token de notificaci칩n y los datos del usuario al backend

    if (expoPushToken) {

     await registerPushTokenOnBackend(

      loginResponse.userId,

      loginResponse.userType, // Usa el userType que viene del backend

      expoPushToken,

      loginResponse.token // Pasa el token de sesi칩n (JWT) para autenticar la petici칩n

     );

     console.log('Token de notificaci칩n registrado con 칠xito en el backend.');

    } else {

     console.warn('No se pudo obtener el token de Expo Push para registrar.');

    }



    // 5. Navegar a la pantalla principal despu칠s de un login exitoso y registro de token

    if (loginResponse.userType === 'estudiante') {

     router.replace('/postulante/dashboard'); // Redirigir al dashboard del postulante

    } else if (loginResponse.userType === 'empresa') {

     router.replace('/empresa/dashboard'); // Redirigir al dashboard de la empresa

    } else {

     // En caso de que el userType devuelto por el backend no sea ni 'postulante' ni 'empresa'

     Alert.alert('Error de inicio de sesi칩n', 'Tipo de usuario no reconocido. Por favor, contacta a soporte.');

    }



   } else {

    // En caso de una respuesta exitosa pero con datos incompletos (raro si el backend est치 bien)

    console.log('LoginScreen: loginResponse es incompleto o falsy:', loginResponse); // <-- A침ade esto

    Alert.alert('Error de inicio de sesi칩n', loginResponse?.mensaje || 'Credenciales inv치lidas o datos de usuario incompletos recibidos.');

   }



  } catch (error: any) {

   // Manejo de errores de la API (ej. 401 Credenciales inv치lidas, Network request failed)

   console.error('Error durante el inicio de sesi칩n o registro de token:', error);

   Alert.alert('Error', error.message || 'Ocurri칩 un error inesperado al iniciar sesi칩n.');

  } finally {

   setIsLoading(false); // Ocultar indicador de carga

  }

 };



 if (!fontsLoaded) {

  return <ActivityIndicator size="large" color={Colors.techBridgeBlue} style={{ flex: 1, justifyContent: 'center' }} />;

 }



 return (

  <View style={styles.loginPostulante}>

   <View style={styles.topNav}>

    <Image

     style={styles.logo}

     source={{ uri: 'https://c.animaapp.com/mOfRBxl8/img/logo-3.png' }}

    />

   </View>

   <View style={styles.landingPageLogin}>

    <View style={styles.frame}>

     <View style={styles.signUpOptions}>

      <TouchableOpacity

       style={[styles.tabBase, activeTab === 'estudiante' ? styles.activeTab : styles.inactiveTab]} // Modificado

       onPress={() => setActiveTab('estudiante')}

      >

       <Text style={[styles.caption, activeTab === 'estudiante' && styles.activeCaption]}>Postulante</Text>

      </TouchableOpacity>

      <TouchableOpacity

       style={[styles.tabBase, activeTab === 'empresa' ? styles.activeTab : styles.inactiveTab]} // Modificado

       onPress={() => setActiveTab('empresa')}

      >

       <Text style={[styles.caption, activeTab === 'empresa' && styles.activeCaption]}>Empresa</Text>

      </TouchableOpacity>

     </View>

     {activeTab === 'estudiante' && (

      <Text style={styles.welcomeBackDude}>Obten m치s oportunidades</Text>

     )}

     {activeTab === 'empresa' && (

      <Text style={styles.welcomeBackDude}>Impulsa tu empresa</Text>

     )}

    </View>



    <View style={styles.forms}>

     <View style={styles.textfield}>

      <Text style={styles.label}>Correo</Text>

      <View style={styles.input}>

       <TextInput

        style={styles.textInputStyle}

        placeholder="Ingresa tu correo"

        placeholderTextColor={Colors.neutrals40}

        value={email}

        onChangeText={setEmail}

        keyboardType="email-address"

        autoCapitalize="none"

       />

      </View>

     </View>

     <View style={styles.textfield}>

      <Text style={styles.label}>Contrase침a</Text>

      <View style={styles.input}>

       <TextInput

        style={styles.textInputStyle}

        placeholder="Ingresa tu contrase침a"

        placeholderTextColor={Colors.neutrals40}

        value={password}

        onChangeText={setPassword}

        secureTextEntry

       />

      </View>

     </View>

    

     <TouchableOpacity style={styles.rememberMe} onPress={() => setRememberMe(!rememberMe)}>

      <View style={styles.checkbox}>

       <Image

        style={styles.checkboxChecked}

        source={{

         uri: rememberMe

          ? 'https://c.animaapp.com/mOfRBxl8/img/checkbox-checked3.svg'

          : 'https://c.animaapp.com/mOfRBxl8/img/checkbox-unchecked.svg', // Aseg칰rate de tener esta imagen

        }}

       />

       <Text style={styles.div}>Recordarme en este dispositivo</Text>

      </View>

     </TouchableOpacity>



     <TouchableOpacity

      style={styles.divWrapper}

      onPress={handleLogin}

      disabled={isLoading}

     >

      {isLoading ? (

       <ActivityIndicator color={Colors.neutrals0} />

      ) : (

       <Text style={styles.caption2}>Iniciar Sesi칩n</Text>

      )}

     </TouchableOpacity>

    </View>



    <View style={styles.alreadyHaveAn}>

     <Text style={styles.dontHaveAn}>쯅o tienes una cuenta?</Text>

     <TouchableOpacity onPress={() => router.push('/signup')}> {/* Asume una ruta de registro */}

      <Text style={styles.signUp}>Crea una cuenta</Text>

     </TouchableOpacity>

    </View>

   </View>

  </View>

 );

}



// --- StyleSheet para React Native ---

const styles = StyleSheet.create({

 loginPostulante: {

  flex: 1,

  backgroundColor: Colors.neutrals0,

  justifyContent: 'center', // 춰NUEVO! Centra los hijos verticalmente

  alignItems: 'center',   // 춰NUEVO! Centra los hijos horizontalmente (si es necesario para todo el contenedor)

  paddingTop: 50,

  paddingVertical: 20, // Opcional: a침adir un poco de padding vertical si todo se pega a los bordes

 },

 topNav: {

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'space-around',

  paddingTop: 37,

  paddingHorizontal: 16,

  paddingBottom: 0,

  width: '100%',

  backgroundColor: Colors.neutrals0,

 },

 logo: {

  width: 240,

  height: 80,

  resizeMode: 'contain',

  marginTop: -1,

 },

 landingPageLogin: {

  flex: 1,

  flexDirection: 'column',

  width: '100%',

  maxWidth: 383,

  alignSelf: 'center',

  alignItems: 'flex-start',

  gap: 24,

  paddingHorizontal: 16,

  paddingVertical: 40,

  backgroundColor: Colors.neutrals0,

 },

 frame: {

  flexDirection: 'column',

  alignItems: 'center',

  gap: 24,

  width: '100%',

 },

 signUpOptions: {

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'center',

 },

 tabMenu: {

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'center',

  paddingVertical: 7,

  paddingHorizontal: 12,

  backgroundColor: Colors.techBridgeLightBlue,

 },

 caption: {

  fontFamily: FontFamilies.epilogueSemiBold,

  fontSize: 16,

  letterSpacing: 0,

  lineHeight: 16 * 1.6,

  color: Colors.neutrals100,

  marginTop: -1,

 },

 activeTab: {

  backgroundColor: Colors.techBridgeLightBlue,

 },

 inactiveTab: {

  backgroundColor: Colors.neutrals0, // El color de fondo cuando NO est치 activo

  // Aqu칤 puedes a침adir un borde si quieres diferenciarlos m치s cuando est치n inactivos

  // borderWidth: 1,

  // borderColor: Colors.neutrals20,

 },

 activeCaption: {

  color: Colors.techBridgeBlue,

 },

 tabBase: {

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'center',

  paddingVertical: 7,

  paddingHorizontal: 12,

  // NO pongas backgroundColor aqu칤 si quieres que el 'inactiveTab' lo defina

  // o si el fondo global del contenedor de pesta침as ya es neutro.

  // Podr칤as poner un borderRadius o un borde aqu칤 si es com칰n para ambos.

 },

 captionWrapper: {

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'center',

  paddingVertical: 7,

  paddingHorizontal: 12,

  backgroundColor: Colors.neutrals0,

 },

 welcomeBackDude: {

  width: '100%',

  fontFamily: FontFamilies.leagueSpartanSemiBold,

  fontSize: 32,

  lineHeight: 38.4,

  textAlign: 'center',

  color: Colors.neutrals100,

 },

 orSignUpWith: {

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'center',

  gap: 8,

  width: '100%',

 },

 line: {

  flex: 1,

  height: 1,

  backgroundColor: Colors.neutrals20,

 },

 orLoginWithEmail: {

  fontFamily: FontFamilies.epilogueRegular,

  fontSize: 16,

  letterSpacing: 0,

  lineHeight: 16 * 1.6,

  color: Colors.neutrals40,

  textAlign: 'center',

  marginTop: -1,

 },

 forms: {

  flexDirection: 'column',

  alignItems: 'flex-start',

  gap: 22,

  width: '100%',

 },

 textfield: {

  flexDirection: 'column',

  alignItems: 'flex-start',

  gap: 4,

  width: '100%',

 },

 label: {

  fontFamily: FontFamilies.epilogueSemiBold,

  fontSize: 16,

  letterSpacing: 0,

  lineHeight: 16 * 1.6,

  color: Colors.neutrals80,

  marginTop: -1,

 },

 input: {

  flexDirection: 'row',

  alignItems: 'center',

  paddingVertical: 12,

  paddingHorizontal: 16,

  width: '100%',

  backgroundColor: Colors.neutrals0,

  borderWidth: 1,

  borderColor: Colors.neutrals20,

 },

 textInputStyle: {

  flex: 1,

  fontFamily: FontFamilies.epilogueRegular,

  fontSize: 16,

  color: Colors.neutrals100,

 },

 rememberMe: {

  width: '100%',

  height: 26,

  justifyContent: 'center',

 },

 checkbox: {

  flexDirection: 'row',

  alignItems: 'center',

  gap: 16,

 },

 checkboxChecked: {

  width: 24,

  height: 24,

  resizeMode: 'contain',

 },

 div: {

  fontFamily: FontFamilies.epilogueRegular,

  fontSize: 16,

  letterSpacing: 0,

  lineHeight: 16 * 1.6,

  color: Colors.neutrals80,

  marginTop: -1,

 },

 divWrapper: {

  paddingVertical: 12,

  paddingHorizontal: 24,

  backgroundColor: Colors.techBridgeBlue,

  flexDirection: 'row',

  alignItems: 'center',

  justifyContent: 'center',

  gap: 10,

  width: '100%',

 },

 caption2: {

  fontFamily: FontFamilies.epilogueBold,

  fontSize: 16,

  letterSpacing: 0,

  lineHeight: 16 * 1.6,

  color: Colors.neutrals0,

  textAlign: 'center',

  marginTop: -1,

 },

 alreadyHaveAn: {

  flexDirection: 'row',

  alignItems: 'flex-start',

  gap: 8,

  marginBottom: -14,

 },

 dontHaveAn: {

  fontFamily: FontFamilies.epilogueRegular,

  fontSize: 16,

  letterSpacing: 0,

  lineHeight: 16 * 1.6,

  color: Colors.black,

  marginTop: -1,

  opacity: 0.7,

 },

 signUp: {

  fontFamily: FontFamilies.interSemiBold,

  fontSize: 16,

  lineHeight: 24,

  color: Colors.techBridgeBlue,

  textAlign: 'center',

  marginTop: -1,

 },

}); // mobile-app/src/services/api.ts



// Aseg칰rate de que esta URL base est칠 bien configurada para tu IP/Emulador

// Si tu IP es 192.168.0.9 y tu backend corre en el puerto 3000

// mobile-app/src/config/api.ts DEBE tener: export const API_BASE_URL = 'http://192.168.0.9:3000';

import { API_BASE_URL } from '../config/api'; // Importa la URL base sin el '/api' final



// Interfaz para la respuesta de registro de token push

interface RegisterPushTokenResponse {

 message: string;

}



// Interfaz para la respuesta de login que el frontend ESPERA y NECESITA

interface FrontendLoginResponse {

 userId: number;

 userType: 'estudiante' | 'empresa'; // 'estudiante' es lo que tu backend devuelve para postulantes

 token: string; // 춰Esto es crucial y tu backend NO lo est치 devolviendo a칰n!

 mensaje?: string;

 estado: number;

}



// Funci칩n para enviar el token de Expo Push al backend

export const registerPushTokenOnBackend = async (

 userId: number,

 userType: 'estudiante' | 'empresa', // Aseg칰rate de que esto coincida con lo que tu backend espera ('estudiante' o 'empresa')

 expoPushToken: string,

 authToken?: string // Opcional: si tu ruta de registro de token en el backend requiere autenticaci칩n

): Promise<RegisterPushTokenResponse> => {

 try {

  const headers: HeadersInit = {

   'Content-Type': 'application/json',

  };

  // Si tu backend protege la ruta /registerPushToken, a침ade el token de autenticaci칩n aqu칤

  if (authToken) {

   headers['Authorization'] = `Bearer ${authToken}`;

  }



  // La ruta completa para el registro de token

  const response = await fetch(`${API_BASE_URL}/api/usuariosMobile/registerPushToken`, {

   method: 'POST',

   headers: headers,

   body: JSON.stringify({

    userId: userId,

    userType: userType,

    expoPushToken: expoPushToken,

   }),

  });



  if (!response.ok) {

   const errorData = await response.json();

   throw new Error(errorData.message || `Error ${response.status}: Failed to register push token.`);

  }



  return response.json(); // Devuelve la respuesta del backend

 } catch (error: any) {

  console.error('Error sending push token to backend:', error.message);

  throw error; // Propaga el error para que pueda ser manejado en el componente de login

 }

};



// Funci칩n para el login, ahora recibe el tipo de usuario

export const loginUser = async (

 credentials: { correo: string; contrasena: string }, // Cambiado a 'correo' y 'contrasena' para coincidir con tu backend

 userType: 'estudiante' | 'empresa' // Recibe el tipo de usuario para seleccionar el endpoint

): Promise<FrontendLoginResponse> => { // Ahora retorna la interfaz que el frontend necesita

 try {

  let loginEndpoint = '';

  if (userType === 'estudiante') {

   loginEndpoint = '/api/usuariosMobile/estudianteLogin'; // Ruta correcta para postulantes

  } else if (userType === 'empresa') {

   loginEndpoint = '/api/usuariosMobile/empresaLogin'; // Ruta correcta para empresas

  } else {

   throw new Error('Tipo de usuario no v치lido para el login.');

  }



  const response = await fetch(`${API_BASE_URL}${loginEndpoint}`, {

   method: 'POST',

   headers: {

    'Content-Type': 'application/json',

   },

   body: JSON.stringify(credentials),

  });

  // Si la respuesta no es OK (ej. 401 Unauthorized, 500 Internal Server Error)

  if (!response.ok) {

   const errorData = await response.json();

   throw new Error(errorData.mensaje || 'Login failed'); // Usa errorData.mensaje

  }



  // ***********************************************************************************

  // *** 춰ATENCI칍N CR칈TICA AQU칈! ***

  // Tu backend actualmente devuelve { estado, mensaje, id }.

  // Para que el frontend funcione correctamente (especialmente con el registro de push token

  // y la navegaci칩n), NECESITA que el backend devuelva:

  // { userId: number, userType: 'estudiante' | 'empresa', token: string }

  //

  // Por ahora, estoy simulando la respuesta esperada para que el frontend no falle,

  // pero DEBES MODIFICAR TU BACKEND para que devuelva 'userType' y un 'token' JWT.

  // ***********************************************************************************



  // Mapea la respuesta actual del backend a la estructura que el frontend espera

  // Esto es una SOLUCI칍N TEMPORAL hasta que modifiques el backend

  const data: FrontendLoginResponse = await response.json();

  console.log('API: Datos recibidos del backend:', data); // <-- A침ade esto

  return data;

 } catch (error: any) {

  console.error('Error during login API call:', error.message);

  throw error; // Propaga el error para que sea manejado por el componente que llama

 }

};



// Puedes a침adir aqu칤 otras funciones para interactuar con tu API... // mobile-app/src/utils/notifications.ts

import * as Notifications from 'expo-notifications';

import * as Device from 'expo-device'; // Importa expo-device

import Constants from 'expo-constants'; // Importa expo-constants

import { Platform } from 'react-native';

import { Router } from 'expo-router'; // Importa el tipo Router para tipado correcto



// Configura c칩mo se deben manejar las notificaciones cuando la app est치 en primer plano

// Esto es importante para decidir si la notificaci칩n se muestra como un banner, si reproduce sonido, etc.

Notifications.setNotificationHandler({

 handleNotification: async () => ({

  shouldShowAlert: true,

  shouldPlaySound: false,

  shouldSetBadge: false,

  // Agrega estas dos propiedades que faltan seg칰n el error

  shouldShowBanner: true, // Esto es generalmente lo que quieres para notificaciones push

  shouldShowList: true,  // Esto es para mostrar en la lista de notificaciones del sistema

 }),

});



/**

* Solicita permisos de notificaci칩n al usuario y obtiene el token de Expo Push para el dispositivo.

* Este token es el que tu backend usar치 para enviar notificaciones push.

* @returns {Promise<string | undefined>} El token de Expo Push o undefined si no se pudo obtener.

*/

export async function registerForPushNotificationsAsync(): Promise<string | undefined> {

 let token;



 // Aseg칰rate de que el c칩digo se ejecute en un dispositivo f칤sico para las notificaciones push

 if (Device.isDevice) {

  // Comprobar el estado actual de los permisos

  const { status: existingStatus } = await Notifications.getPermissionsAsync();

  let finalStatus = existingStatus;



  // Si los permisos no han sido otorgados, solicitarlos

  if (existingStatus !== 'granted') {

   const { status } = await Notifications.requestPermissionsAsync();

   finalStatus = status;

  }



  // Si los permisos no se otorgaron, alertar al usuario

  if (finalStatus !== 'granted') {

   alert('Failed to get push token for push notification!');

   return;

  }



  // Si es Android, configura un canal de notificaci칩n (obligatorio desde Android 8.0)

  if (Platform.OS === 'android') {

   await Notifications.setNotificationChannelAsync('default', {

    name: 'default',

    importance: Notifications.AndroidImportance.MAX, // Muestra la notificaci칩n de forma destacada

    vibrationPattern: [0, 250, 250, 250], // Patr칩n de vibraci칩n

    lightColor: '#FF231F7C', // Color de la luz LED si el dispositivo lo soporta

   });

  }



  // Obtener el token de Expo Push

 

  token = (await Notifications.getExpoPushTokenAsync({

   projectId: Constants.expoConfig?.extra?.eas?.projectId || Constants.expoConfig?.owner // Expo Router usa projectId de app.json/app.config.js o el owner

  })).data;



  console.log('Expo Push Token:', token);

  return token;



 } else {

  // Si no es un dispositivo f칤sico, no se pueden obtener tokens de push

  alert('Must use physical device for Push Notifications');

 }



 return undefined;

}



/**

* Escucha las notificaciones recibidas y las interacciones del usuario con ellas.

* @param {Router} router - El objeto 'router' de Expo Router para la navegaci칩n.

* @returns {() => void} Una funci칩n para limpiar los listeners al desmontar el componente.

*/

export function setupNotificationListeners(router: Router) { // Cambiado 'any' por 'Router' para mejor tipado

 // Listener para notificaciones recibidas mientras la app est치 en primer plano

 const notificationListener = Notifications.addNotificationReceivedListener(notification => {

  console.log("Notification received in foreground:", notification);

  // Aqu칤 puedes hacer algo en la UI si la app est치 abierta, como mostrar un banner flotante

 });



 // Listener para cuando el usuario presiona o interact칰a con una notificaci칩n

 const responseListener = Notifications.addNotificationResponseReceivedListener(response => {

  console.log("Notification tapped/interacted:", response);

  // Extraer datos personalizados de la notificaci칩n

  // Asumimos que `data` contiene `{ screen: 'postulanteNotificaciones', itemId: 'ID_DE_LA_OFERTA' }`

  const { screen, ...data } = response.notification.request.content.data; // Desestructuramos 'screen' y el resto de 'data'



  // Define el tipo esperado para los par치metros del router

  type RouterParams = Record<string, string | number | (string | number)[] | null | undefined>;



  if (typeof screen === 'string') { // Asegurarnos de que 'screen' sea una cadena

   console.log(`Navigating to ${screen} with data:`, data);



   // L칩gica de redirecci칩n basada en la pantalla y, opcionalmente, otros datos

   switch (screen) {

    case 'postulanteDashboard':

     router.push('/postulante/dashboard');

     break;

    case 'postulanteNotificaciones':

     // Ejemplo: Si itemId es el ID de una oferta, navegar a una pantalla de detalle de oferta

     router.push({ pathname: '/postulante/notificaciones', params: data as RouterParams});

     break;

    case 'empresaDashboard':

     router.push('/empresa/dashboard');

     break;

    case 'empresaNotificaciones':

     // Ejemplo: Si itemId es el ID de un postulante, navegar a una pantalla de detalle del postulante

     router.push({ pathname: '/empresa/notificaciones', params: data as RouterParams});

     break;

    // A침ade m치s casos si tienes otras pantallas a las que las notificaciones pueden redirigir

    default:

     // Redirecci칩n por defecto si la pantalla no es reconocida (ej. al dashboard principal)

     // Puedes usar router.replace si quieres que no se pueda volver a la notificaci칩n

     router.push('/postulante/dashboard'); // O a una ruta gen칠rica como '/home'

     break;

   }

  } else {

   console.warn("Notification data 'screen' is missing or not a string, cannot navigate.");

  }

 });



 // Funci칩n para limpiar los listeners

 return () => {

  Notifications.removeNotificationSubscription(notificationListener);

  Notifications.removeNotificationSubscription(responseListener);

 };

}



// Funci칩n opcional para enviar una notificaci칩n de prueba localmente (solo para depuraci칩n)

export async function schedulePushNotification() {

 await Notifications.scheduleNotificationAsync({

  content: {

   title: "T칤tulo de Prueba! 游닓",

   body: 'Este es el cuerpo de la notificaci칩n de prueba.',

   data: {

    screen: 'postulanteNotificaciones', // Ejemplo: redirige a la pantalla de notificaciones del postulante

    itemId: 'oferta123', // Ejemplo de un ID de item

    messageId: 'msg456'

   },

  },

  // Modifica el trigger para incluir 'type'

  trigger: {

   repeats: false, // Opcional: true si quieres que se repita

   seconds: 2,

   // La propiedad 'type' podr칤a ser necesaria para algunas configuraciones

   // pero 'seconds' ya implica un TimeIntervalTrigger.

   // Si el error persiste, intenta con esto, aunque es menos com칰n para 'seconds':

   // type: 'timeInterval', // Si esto da error, probemos sin 칠l.

  } as Notifications.TimeIntervalTriggerInput,

 });

} //mobile-app/app.json: {

 "expo": {

  "name": "mobile-app",

  "slug": "mobile-app",

  "version": "1.0.5",

  "orientation": "portrait",

  "icon": "./assets/images/icon.png",

  "scheme": "mobileapp",

  "userInterfaceStyle": "automatic",

  "newArchEnabled": true,

  "ios": {

   "supportsTablet": true

  },

  "android": {

   "adaptiveIcon": {

    "foregroundImage": "./assets/images/adaptive-icon.png",

    "backgroundColor": "#ffffff"

   },

   "edgeToEdgeEnabled": true,

   "versionCode": 5,

   "package": "com.techbridge.app",

   "googleServicesFile": "./google-services.json"

  },

  "web": {

   "bundler": "metro",

   "output": "static",

   "favicon": "./assets/images/favicon.png"

  },

  "plugins": [

   "expo-router",

   [

    "expo-splash-screen",

    {

     "image": "./assets/images/splash-icon.png",

     "imageWidth": 200,

     "resizeMode": "contain",

     "backgroundColor": "#ffffff"

    }

   ]

  ],

  "experiments": {

   "typedRoutes": true

  },

  "extra": {

   "router": {},

   "eas": {

    "projectId": "316931be-2ce3-444d-b761-9166807370fc"

   }

  }

 }

}